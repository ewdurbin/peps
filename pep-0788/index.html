
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta name="color-scheme" content="light dark">
    <title>PEP 788 – Reimagining native threads | peps.python.org</title>
    <link rel="shortcut icon" href="../_static/py.png">
    <link rel="canonical" href="https://peps.python.org/pep-0788/">
    <link rel="stylesheet" href="../_static/style.css" type="text/css">
    <link rel="stylesheet" href="../_static/mq.css" type="text/css">
    <link rel="stylesheet" href="../_static/pygments.css" type="text/css" media="(prefers-color-scheme: light)" id="pyg-light">
    <link rel="stylesheet" href="../_static/pygments_dark.css" type="text/css" media="(prefers-color-scheme: dark)" id="pyg-dark">
    <link rel="alternate" type="application/rss+xml" title="Latest PEPs" href="https://peps.python.org/peps.rss">
    <meta property="og:title" content='PEP 788 – Reimagining native threads | peps.python.org'>
    <meta property="og:description" content="PyGILState_Ensure(), PyGILState_Release(), and other related functions in the PyGILState family are the most common way to create native threads that interact with Python. They have been the standard for over twenty years (PEP 311). But, over time, thes...">
    <meta property="og:type" content="website">
    <meta property="og:url" content="https://peps.python.org/pep-0788/">
    <meta property="og:site_name" content="Python Enhancement Proposals (PEPs)">
    <meta property="og:image" content="https://peps.python.org/_static/og-image.png">
    <meta property="og:image:alt" content="Python PEPs">
    <meta property="og:image:width" content="200">
    <meta property="og:image:height" content="200">
    <meta name="description" content="PyGILState_Ensure(), PyGILState_Release(), and other related functions in the PyGILState family are the most common way to create native threads that interact with Python. They have been the standard for over twenty years (PEP 311). But, over time, thes...">
    <meta name="theme-color" content="#3776ab">
</head>
<body>
    
<svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
  <symbol id="svg-sun-half" viewBox="0 0 24 24" pointer-events="all">
    <title>Following system colour scheme</title>
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none"
         stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
      <circle cx="12" cy="12" r="9"></circle>
      <path d="M12 3v18m0-12l4.65-4.65M12 14.3l7.37-7.37M12 19.6l8.85-8.85"></path>
    </svg>
  </symbol>
  <symbol id="svg-moon" viewBox="0 0 24 24" pointer-events="all">
    <title>Selected dark colour scheme</title>
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none"
         stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
      <path stroke="none" d="M0 0h24v24H0z" fill="none"></path>
      <path d="M12 3c.132 0 .263 0 .393 0a7.5 7.5 0 0 0 7.92 12.446a9 9 0 1 1 -8.313 -12.454z"></path>
    </svg>
  </symbol>
  <symbol id="svg-sun" viewBox="0 0 24 24" pointer-events="all">
    <title>Selected light colour scheme</title>
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none"
         stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
      <circle cx="12" cy="12" r="5"></circle>
      <line x1="12" y1="1" x2="12" y2="3"></line>
      <line x1="12" y1="21" x2="12" y2="23"></line>
      <line x1="4.22" y1="4.22" x2="5.64" y2="5.64"></line>
      <line x1="18.36" y1="18.36" x2="19.78" y2="19.78"></line>
      <line x1="1" y1="12" x2="3" y2="12"></line>
      <line x1="21" y1="12" x2="23" y2="12"></line>
      <line x1="4.22" y1="19.78" x2="5.64" y2="18.36"></line>
      <line x1="18.36" y1="5.64" x2="19.78" y2="4.22"></line>
    </svg>
  </symbol>
</svg>
    <script>

        document.documentElement.dataset.colour_scheme = localStorage.getItem("colour_scheme") || "auto"
    </script>
    <section id="pep-page-section">
        <header>
            <h1>Python Enhancement Proposals</h1>
            <ul class="breadcrumbs">
                <li><a href="https://www.python.org/" title="The Python Programming Language">Python</a> &raquo; </li>
                <li><a href="../pep-0000/">PEP Index</a> &raquo; </li>
                <li>PEP 788</li>
            </ul>
            <button id="colour-scheme-cycler" onClick="setColourScheme(nextColourScheme())">
                <svg aria-hidden="true" class="colour-scheme-icon-when-auto"><use href="#svg-sun-half"></use></svg>
                <svg aria-hidden="true" class="colour-scheme-icon-when-dark"><use href="#svg-moon"></use></svg>
                <svg aria-hidden="true" class="colour-scheme-icon-when-light"><use href="#svg-sun"></use></svg>
                <span class="visually-hidden">Toggle light / dark / auto colour theme</span>
            </button>
        </header>
        <article>
            <section id="pep-content">
<h1 class="page-title">PEP 788 – Reimagining native threads</h1>
<dl class="rfc2822 field-list simple">
<dt class="field-odd">Author<span class="colon">:</span></dt>
<dd class="field-odd">Peter Bierma &lt;zintensitydev&#32;&#97;t&#32;gmail.com&gt;</dd>
<dt class="field-even">Sponsor<span class="colon">:</span></dt>
<dd class="field-even">Victor Stinner &lt;vstinner&#32;&#97;t&#32;python.org&gt;</dd>
<dt class="field-odd">Discussions-To<span class="colon">:</span></dt>
<dd class="field-odd"><a class="reference external" href="https://discuss.python.org/t/89863">Discourse thread</a></dd>
<dt class="field-even">Status<span class="colon">:</span></dt>
<dd class="field-even"><abbr title="Proposal under active discussion and revision">Draft</abbr></dd>
<dt class="field-odd">Type<span class="colon">:</span></dt>
<dd class="field-odd"><abbr title="Normative PEP with a new feature for Python, implementation change for CPython or interoperability standard for the ecosystem">Standards Track</abbr></dd>
<dt class="field-even">Created<span class="colon">:</span></dt>
<dd class="field-even">23-Apr-2025</dd>
<dt class="field-odd">Python-Version<span class="colon">:</span></dt>
<dd class="field-odd">3.15</dd>
<dt class="field-even">Post-History<span class="colon">:</span></dt>
<dd class="field-even"><a class="reference external" href="https://discuss.python.org/t/83959" title="Discourse thread">10-Mar-2025</a>,
<a class="reference external" href="https://discuss.python.org/t/89863" title="Discourse thread">27-Apr-2025</a></dd>
</dl>
<hr class="docutils" />
<section id="contents">
<details><summary>Table of Contents</summary><ul class="simple">
<li><a class="reference internal" href="#abstract">Abstract</a></li>
<li><a class="reference internal" href="#motivation">Motivation</a><ul>
<li><a class="reference internal" href="#native-threads-will-always-hang-during-finalization">Native threads will always hang during finalization</a><ul>
<li><a class="reference internal" href="#using-py-isfinalizing-is-insufficient">Using <code class="docutils literal notranslate"><span class="pre">Py_IsFinalizing</span></code> is insufficient</a></li>
<li><a class="reference internal" href="#daemon-threads-can-cause-finalization-deadlocks">Daemon threads can cause finalization deadlocks</a></li>
<li><a class="reference internal" href="#we-can-t-change-finalization-behavior-for-pygilstate-ensure">We can’t change finalization behavior for <code class="docutils literal notranslate"><span class="pre">PyGILState_Ensure</span></code></a></li>
</ul>
</li>
<li><a class="reference internal" href="#the-existing-apis-are-broken-and-misleading">The existing APIs are broken and misleading</a><ul>
<li><a class="reference internal" href="#pygilstate-ensure-generally-crashes-during-finalization"><code class="docutils literal notranslate"><span class="pre">PyGILState_Ensure</span></code> generally crashes during finalization</a></li>
<li><a class="reference internal" href="#the-term-gil-is-tricky-for-free-threading">The term “GIL” is tricky for free-threading</a></li>
</ul>
</li>
<li><a class="reference internal" href="#subinterpreters-don-t-work-with-pygilstate-ensure">Subinterpreters don’t work with <code class="docutils literal notranslate"><span class="pre">PyGILState_Ensure</span></code></a><ul>
<li><a class="reference internal" href="#interpreters-can-concurrently-shut-down">Interpreters can concurrently shut down</a></li>
</ul>
</li>
</ul>
</li>
<li><a class="reference internal" href="#rationale">Rationale</a><ul>
<li><a class="reference internal" href="#replacing-the-old-apis">Replacing the old APIs</a></li>
<li><a class="reference internal" href="#a-light-layer-of-magic">A light layer of magic</a></li>
<li><a class="reference internal" href="#bikeshedding-and-the-pythreadstate-namespace">Bikeshedding and the <code class="docutils literal notranslate"><span class="pre">PyThreadState</span></code> namespace</a></li>
<li><a class="reference internal" href="#preventing-interpreter-finalization-with-references">Preventing interpreter finalization with references</a></li>
</ul>
</li>
<li><a class="reference internal" href="#specification">Specification</a><ul>
<li><a class="reference internal" href="#daemon-and-non-daemon-threads">Daemon and non-daemon threads</a></li>
<li><a class="reference internal" href="#interpreter-reference-counting">Interpreter reference counting</a></li>
<li><a class="reference internal" href="#ensuring-and-releasing-thread-states">Ensuring and releasing thread states</a></li>
<li><a class="reference internal" href="#deprecation-of-pygilstate-apis">Deprecation of <code class="docutils literal notranslate"><span class="pre">PyGILState</span></code> APIs</a></li>
</ul>
</li>
<li><a class="reference internal" href="#backwards-compatibility">Backwards Compatibility</a></li>
<li><a class="reference internal" href="#security-implications">Security Implications</a></li>
<li><a class="reference internal" href="#how-to-teach-this">How to Teach This</a><ul>
<li><a class="reference internal" href="#examples">Examples</a><ul>
<li><a class="reference internal" href="#single-threaded-example">Single-threaded example</a></li>
<li><a class="reference internal" href="#transitioning-from-old-functions">Transitioning from old functions</a></li>
<li><a class="reference internal" href="#daemon-thread-example">Daemon thread example</a></li>
<li><a class="reference internal" href="#asynchronous-callback-example">Asynchronous callback example</a></li>
</ul>
</li>
</ul>
</li>
<li><a class="reference internal" href="#reference-implementation">Reference Implementation</a></li>
<li><a class="reference internal" href="#rejected-ideas">Rejected Ideas</a><ul>
<li><a class="reference internal" href="#using-an-interpreter-id-instead-of-a-interpreter-state-for-pythreadstate-ensure">Using an interpreter ID instead of a interpreter state for <code class="docutils literal notranslate"><span class="pre">PyThreadState_Ensure</span></code></a></li>
<li><a class="reference internal" href="#exposing-an-activate-deactivate-api-instead-of-ensure-clear">Exposing an <code class="docutils literal notranslate"><span class="pre">Activate</span></code>/<code class="docutils literal notranslate"><span class="pre">Deactivate</span></code> API instead of <code class="docutils literal notranslate"><span class="pre">Ensure</span></code>/<code class="docutils literal notranslate"><span class="pre">Clear</span></code></a></li>
<li><a class="reference internal" href="#using-pystatus-for-the-return-value-of-pythreadstate-ensure">Using <code class="docutils literal notranslate"><span class="pre">PyStatus</span></code> for the return value of <code class="docutils literal notranslate"><span class="pre">PyThreadState_Ensure</span></code></a></li>
</ul>
</li>
<li><a class="reference internal" href="#open-issues">Open Issues</a><ul>
<li><a class="reference internal" href="#when-should-the-legacy-apis-be-removed">When should the legacy APIs be removed?</a></li>
</ul>
</li>
<li><a class="reference internal" href="#copyright">Copyright</a></li>
</ul>
</details></section>
<section id="abstract">
<h2><a class="toc-backref" href="#abstract" role="doc-backlink">Abstract</a></h2>
<p><a class="reference external" href="https://docs.python.org/3/c-api/init.html#c.PyGILState_Ensure" title="(in Python v3.13)"><code class="xref c c-func docutils literal notranslate"><span class="pre">PyGILState_Ensure()</span></code></a>, <a class="reference external" href="https://docs.python.org/3/c-api/init.html#c.PyGILState_Release" title="(in Python v3.13)"><code class="xref c c-func docutils literal notranslate"><span class="pre">PyGILState_Release()</span></code></a>, and other related
functions in the <code class="docutils literal notranslate"><span class="pre">PyGILState</span></code> family are the most common way to create
native threads that interact with Python. They have been the standard for over
twenty years (<a class="pep reference internal" href="../pep-0311/" title="PEP 311 – Simplified Global Interpreter Lock Acquisition for Extensions">PEP 311</a>). But, over time, these functions have
become problematic:</p>
<ul class="simple">
<li>They aren’t safe for finalization, either causing the calling thread to hang or
crashing it with a segmentation fault, preventing further execution.</li>
<li>When they’re called before finalization, they force the thread to be
“daemon”, meaning that an interpreter won’t wait for it to reach any point
of execution. This is mostly frustrating for developers, but can lead to
deadlocks!</li>
<li>Subinterpreters don’t play nicely with them, because they all assume that
the main interpreter is the only one that exists. A fresh thread (that is,
has never had a thread state) that calls <a class="reference external" href="https://docs.python.org/3/c-api/init.html#c.PyGILState_Ensure" title="(in Python v3.13)"><code class="xref c c-func docutils literal notranslate"><span class="pre">PyGILState_Ensure()</span></code></a> will
always be for the main interpreter.</li>
<li>The term “GIL” in the name is quite confusing for users of free-threaded
Python. There isn’t a GIL, why do they still have to call it?</li>
</ul>
<p>This PEP intends to fix all of these issues by providing two new functions,
<a class="reference internal" href="#c.PyThreadState_Ensure" title="PyThreadState_Ensure"><code class="xref c c-func docutils literal notranslate"><span class="pre">PyThreadState_Ensure()</span></code></a> and <a class="reference internal" href="#c.PyThreadState_Release" title="PyThreadState_Release"><code class="xref c c-func docutils literal notranslate"><span class="pre">PyThreadState_Release()</span></code></a>, as a more
correct and safer replacement for <a class="reference external" href="https://docs.python.org/3/c-api/init.html#c.PyGILState_Ensure" title="(in Python v3.13)"><code class="xref c c-func docutils literal notranslate"><span class="pre">PyGILState_Ensure()</span></code></a> and
<a class="reference external" href="https://docs.python.org/3/c-api/init.html#c.PyGILState_Release" title="(in Python v3.13)"><code class="xref c c-func docutils literal notranslate"><span class="pre">PyGILState_Release()</span></code></a>. For example:</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">PyThreadState_Ensure</span><span class="p">(</span><span class="n">interp</span><span class="p">)</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="mi">0</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="n">fputs</span><span class="p">(</span><span class="s">&quot;Python is shutting down&quot;</span><span class="p">,</span><span class="w"> </span><span class="n">stderr</span><span class="p">);</span>
<span class="w">    </span><span class="k">return</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/* Interact with Python, without worrying about finalization. */</span>
<span class="c1">// ...</span>

<span class="n">PyThreadState_Release</span><span class="p">();</span>
</pre></div>
</div>
<p>This is achieved by introducing two concepts into the C API:</p>
<ul class="simple">
<li>“Daemon” and “non-daemon” threads, similar to how it works in the
<a class="reference external" href="https://docs.python.org/3/library/threading.html#module-threading" title="(in Python v3.13)"><code class="xref py py-mod docutils literal notranslate"><span class="pre">threading</span></code></a> module.</li>
<li>Interpreter reference counts which prevent an interpreter from finalizing.</li>
</ul>
<p>In <a class="reference internal" href="#c.PyThreadState_Ensure" title="PyThreadState_Ensure"><code class="xref c c-func docutils literal notranslate"><span class="pre">PyThreadState_Ensure()</span></code></a>, both of these ideas are applied. The
calling thread is to store a reference to an interpreter via
<a class="reference internal" href="#c.PyInterpreterState_Hold" title="PyInterpreterState_Hold"><code class="xref c c-func docutils literal notranslate"><span class="pre">PyInterpreterState_Hold()</span></code></a>. <a class="reference internal" href="#c.PyInterpreterState_Hold" title="PyInterpreterState_Hold"><code class="xref c c-func docutils literal notranslate"><span class="pre">PyInterpreterState_Hold()</span></code></a>
increases the reference count of an interpreter, requiring the thread
to finish (by eventually calling <a class="reference internal" href="#c.PyThreadState_Release" title="PyThreadState_Release"><code class="xref c c-func docutils literal notranslate"><span class="pre">PyThreadState_Release()</span></code></a>) before
beginning finalization.</p>
<p>For example, creating a native thread with this API would look something
like this:</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="k">static</span><span class="w"> </span><span class="n">PyObject</span><span class="w"> </span><span class="o">*</span>
<span class="nf">my_method</span><span class="p">(</span><span class="n">PyObject</span><span class="w"> </span><span class="o">*</span><span class="n">self</span><span class="p">,</span><span class="w"> </span><span class="n">PyObject</span><span class="w"> </span><span class="o">*</span><span class="n">unused</span><span class="p">)</span>
<span class="p">{</span>
<span class="w">    </span><span class="n">PyThread_handle_t</span><span class="w"> </span><span class="n">handle</span><span class="p">;</span>
<span class="w">    </span><span class="n">PyThead_indent_t</span><span class="w"> </span><span class="n">indent</span><span class="p">;</span>

<span class="w">    </span><span class="n">PyInterpreterState</span><span class="w"> </span><span class="o">*</span><span class="n">interp</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">PyInterpreterState_Hold</span><span class="p">();</span>
<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">PyThread_start_joinable_thread</span><span class="p">(</span><span class="n">thread_func</span><span class="p">,</span><span class="w"> </span><span class="n">interp</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">ident</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">handle</span><span class="p">)</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="mi">0</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="n">PyInterpreterState_Release</span><span class="p">(</span><span class="n">interp</span><span class="p">);</span>
<span class="w">        </span><span class="k">return</span><span class="w"> </span><span class="nb">NULL</span><span class="p">;</span>
<span class="w">    </span><span class="p">}</span>
<span class="w">    </span><span class="cm">/* The thread will always attach and finish, because we increased</span>
<span class="cm">       the reference count of the interpreter. */</span>
<span class="w">    </span><span class="n">Py_RETURN_NONE</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
</section>
<section id="motivation">
<h2><a class="toc-backref" href="#motivation" role="doc-backlink">Motivation</a></h2>
<section id="native-threads-will-always-hang-during-finalization">
<h3><a class="toc-backref" href="#native-threads-will-always-hang-during-finalization" role="doc-backlink">Native threads will always hang during finalization</a></h3>
<p>Many codebases might need to call Python code in highly-asynchronous
situations where the interpreter is already finalizing, or might finalize, and
want to continue running code after the Python call. This desire has been
<a class="reference external" href="https://discuss.python.org/t/78850/">brought up by users</a>.
For example, a callback that wants to call Python code might be invoked when:</p>
<ul class="simple">
<li>A kernel has finished running on a GPU.</li>
<li>A network packet was received.</li>
<li>A thread has quit, and a native library is executing static finalizers of
thread local storage.</li>
</ul>
<p>In the current C API, any non-Python thread (one not created via the
<a class="reference external" href="https://docs.python.org/3/library/threading.html#module-threading" title="(in Python v3.13)"><code class="xref py py-mod docutils literal notranslate"><span class="pre">threading</span></code></a> module) is considered to be “daemon”, meaning that the interpreter
won’t wait on that thread to finalize. Instead, the interpreter will hang the
thread when it goes to <a class="reference external" href="https://docs.python.org/3.14/glossary.html#term-attached-thread-state" title="(in Python v3.14)"><span class="xref std std-term">attach</span></a> a <a class="reference external" href="https://docs.python.org/3.14/glossary.html#term-thread-state" title="(in Python v3.14)"><span class="xref std std-term">thread state</span></a>,
making it unusable past that point. Attaching a thread state can happen at
any point when invoking Python, such as releasing the GIL in-between bytecode
instructions, or when a C function exits a <a class="reference external" href="https://docs.python.org/3/c-api/init.html#c.Py_BEGIN_ALLOW_THREADS" title="(in Python v3.13)"><code class="xref c c-macro docutils literal notranslate"><span class="pre">Py_BEGIN_ALLOW_THREADS</span></code></a>
block. (Note that hanging the thread is relatively new behavior; in prior
versions, the thread would terminate, but the issue is the same.)</p>
<p>This means that any non-Python thread may be terminated at any point, which
is severely limiting for users who want to do more than just execute Python
code in their stream of calls (for example, C++ executing finalizers in
<em>addition</em> to calling Python).</p>
<section id="using-py-isfinalizing-is-insufficient">
<h4><a class="toc-backref" href="#using-py-isfinalizing-is-insufficient" role="doc-backlink">Using <code class="docutils literal notranslate"><span class="pre">Py_IsFinalizing</span></code> is insufficient</a></h4>
<p>The <a class="reference external" href="https://docs.python.org/3/c-api/init.html#gilstate" title="(in Python v3.13)"><span class="xref std std-ref">docs</span></a>
currently recommend <a class="reference external" href="https://docs.python.org/3/c-api/init.html#c.Py_IsFinalizing" title="(in Python v3.13)"><code class="xref c c-func docutils literal notranslate"><span class="pre">Py_IsFinalizing()</span></code></a> to guard against termination of
the thread:</p>
<blockquote>
<div>Calling this function from a thread when the runtime is finalizing will
terminate the thread, even if the thread was not created by Python. You
can use <code class="docutils literal notranslate"><span class="pre">Py_IsFinalizing()</span></code> or <code class="docutils literal notranslate"><span class="pre">sys.is_finalizing()</span></code> to check if the
interpreter is in process of being finalized before calling this function
to avoid unwanted termination.</div></blockquote>
<p>Unfortunately, this isn’t correct, because of time-of-call to time-of-use
issues; the interpreter might not be finalizing during the call to
<a class="reference external" href="https://docs.python.org/3/c-api/init.html#c.Py_IsFinalizing" title="(in Python v3.13)"><code class="xref c c-func docutils literal notranslate"><span class="pre">Py_IsFinalizing()</span></code></a>, but it might start finalizing immediately afterwards, which
would cause the attachment of a thread state (typically via
<a class="reference external" href="https://docs.python.org/3/c-api/init.html#c.PyGILState_Ensure" title="(in Python v3.13)"><code class="xref c c-func docutils literal notranslate"><span class="pre">PyGILState_Ensure()</span></code></a>) to hang the thread.</p>
</section>
<section id="daemon-threads-can-cause-finalization-deadlocks">
<h4><a class="toc-backref" href="#daemon-threads-can-cause-finalization-deadlocks" role="doc-backlink">Daemon threads can cause finalization deadlocks</a></h4>
<p>When acquiring locks, it’s extremely important to detach the thread state to
prevent deadlocks. This is true on both the with-GIL and free-threaded builds.
When the GIL is enabled, a deadlock can occur pretty easily when acquiring a
lock if the GIL wasn’t released, and lock-ordering deadlocks can still occur
free-threaded builds if the thread state wasn’t detached.</p>
<p>So, all code that needs to work with locks need to detach the thread state.
In C, this is almost always done via <a class="reference external" href="https://docs.python.org/3/c-api/init.html#c.Py_BEGIN_ALLOW_THREADS" title="(in Python v3.13)"><code class="xref c c-macro docutils literal notranslate"><span class="pre">Py_BEGIN_ALLOW_THREADS</span></code></a> and
<a class="reference external" href="https://docs.python.org/3/c-api/init.html#c.Py_END_ALLOW_THREADS" title="(in Python v3.13)"><code class="xref c c-macro docutils literal notranslate"><span class="pre">Py_END_ALLOW_THREADS</span></code></a>, in a code block that looks something like this:</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="n">Py_BEGIN_ALLOW_THREADS</span>
<span class="nf">acquire_lock</span><span class="p">();</span>
<span class="n">Py_END_ALLOW_THREADS</span>
</pre></div>
</div>
<p>Again, in a daemon thread, <a class="reference external" href="https://docs.python.org/3/c-api/init.html#c.Py_END_ALLOW_THREADS" title="(in Python v3.13)"><code class="xref c c-macro docutils literal notranslate"><span class="pre">Py_END_ALLOW_THREADS</span></code></a> will hang the thread
if the interpreter is finalizing. But, <a class="reference external" href="https://docs.python.org/3/c-api/init.html#c.Py_BEGIN_ALLOW_THREADS" title="(in Python v3.13)"><code class="xref c c-macro docutils literal notranslate"><span class="pre">Py_BEGIN_ALLOW_THREADS</span></code></a> will
<em>not</em> hang the thread; the lock will be acquired, and <em>then</em> the thread will
be hung! Once that happens, nothing can try to acquire that lock without
deadlocking. The main thread will continue to run finalizers past that point,
though. If any of those finalizers try to acquire the lock, deadlock ensues.</p>
<p>This affects CPython itself, and there’s not much that can be done
to fix it. For example, <a class="reference external" href="https://github.com/python/cpython/issues/129536">python/cpython#129536</a>
remarks that the <a class="reference external" href="https://docs.python.org/3/library/ssl.html#module-ssl" title="(in Python v3.13)"><code class="xref py py-mod docutils literal notranslate"><span class="pre">ssl</span></code></a> module can emit a fatal error when used at
finalization, because a daemon thread got hung while holding the lock. There
are workarounds for this for pure-Python code, but native threads don’t have
such an option.</p>
</section>
<section id="we-can-t-change-finalization-behavior-for-pygilstate-ensure">
<span id="pep-788-hanging-compat"></span><h4><a class="toc-backref" href="#we-can-t-change-finalization-behavior-for-pygilstate-ensure" role="doc-backlink">We can’t change finalization behavior for <code class="docutils literal notranslate"><span class="pre">PyGILState_Ensure</span></code></a></h4>
<p>There will always have to be a point in a Python program where
<a class="reference external" href="https://docs.python.org/3/c-api/init.html#c.PyGILState_Ensure" title="(in Python v3.13)"><code class="xref c c-func docutils literal notranslate"><span class="pre">PyGILState_Ensure()</span></code></a> can no longer acquire the GIL (or more correctly,
attach a thread state). If the interpreter is long dead, then Python
obviously can’t give a thread a way to invoke it.
<a class="reference external" href="https://docs.python.org/3/c-api/init.html#c.PyGILState_Ensure" title="(in Python v3.13)"><code class="xref c c-func docutils literal notranslate"><span class="pre">PyGILState_Ensure()</span></code></a> doesn’t have any meaningful way to return a
failure, so it has no choice but to terminate the thread or emit a fatal
error, as noted in <a class="reference external" href="https://github.com/python/cpython/issues/124622">python/cpython#124622</a>:</p>
<blockquote>
<div>I think a new GIL acquisition and release C API would be needed. The way
the existing ones get used in existing C code is not amenible to suddenly
bolting an error state onto; none of the existing C code is written that
way. After the call they always just assume they have the GIL and can
proceed. The API was designed as “it’ll block and only return once it has
the GIL” without any other option.</div></blockquote>
<p>For this reason, we can’t make any real changes to how <a class="reference external" href="https://docs.python.org/3/c-api/init.html#c.PyGILState_Ensure" title="(in Python v3.13)"><code class="xref c c-func docutils literal notranslate"><span class="pre">PyGILState_Ensure()</span></code></a>
works for finalization, because it would break existing code. Similarly, threads
created with the existing C API will have to remain daemon, because extensions
that implement native threads aren’t guaranteed to work during finalization.</p>
</section>
</section>
<section id="the-existing-apis-are-broken-and-misleading">
<h3><a class="toc-backref" href="#the-existing-apis-are-broken-and-misleading" role="doc-backlink">The existing APIs are broken and misleading</a></h3>
<p>There are currently two public ways for a user to create and attach their own
<a class="reference external" href="https://docs.python.org/3.14/glossary.html#term-thread-state" title="(in Python v3.14)"><span class="xref std std-term">thread state</span></a>; manual use of <a class="reference external" href="https://docs.python.org/3/c-api/init.html#c.PyThreadState_New" title="(in Python v3.13)"><code class="xref c c-func docutils literal notranslate"><span class="pre">PyThreadState_New()</span></code></a> &amp; <a class="reference external" href="https://docs.python.org/3/c-api/init.html#c.PyThreadState_Swap" title="(in Python v3.13)"><code class="xref c c-func docutils literal notranslate"><span class="pre">PyThreadState_Swap()</span></code></a>,
and <a class="reference external" href="https://docs.python.org/3/c-api/init.html#c.PyGILState_Ensure" title="(in Python v3.13)"><code class="xref c c-func docutils literal notranslate"><span class="pre">PyGILState_Ensure()</span></code></a>. The latter, <a class="reference external" href="https://docs.python.org/3/c-api/init.html#c.PyGILState_Ensure" title="(in Python v3.13)"><code class="xref c c-func docutils literal notranslate"><span class="pre">PyGILState_Ensure()</span></code></a>,
is <a class="reference external" href="https://grep.app/search?q=pygilstate_ensure">significantly more common</a>.</p>
<section id="pygilstate-ensure-generally-crashes-during-finalization">
<h4><a class="toc-backref" href="#pygilstate-ensure-generally-crashes-during-finalization" role="doc-backlink"><code class="docutils literal notranslate"><span class="pre">PyGILState_Ensure</span></code> generally crashes during finalization</a></h4>
<p>At the time of writing, the current behavior of <a class="reference external" href="https://docs.python.org/3/c-api/init.html#c.PyGILState_Ensure" title="(in Python v3.13)"><code class="xref c c-func docutils literal notranslate"><span class="pre">PyGILState_Ensure()</span></code></a> does not
match the documentation. Instead of hanging the thread during finalization
as previously noted, it’s extremely common for it to crash with a segmentation
fault. This is a <a class="reference external" href="https://github.com/python/cpython/issues/124619">known issue</a>
that could, in theory, be fixed in CPython, but it’s definitely worth noting
here. Incidentally, acceptance and implementation of this PEP will likely fix
the existing crashes caused by <a class="reference external" href="https://docs.python.org/3/c-api/init.html#c.PyGILState_Ensure" title="(in Python v3.13)"><code class="xref c c-func docutils literal notranslate"><span class="pre">PyGILState_Ensure()</span></code></a>.</p>
</section>
<section id="the-term-gil-is-tricky-for-free-threading">
<h4><a class="toc-backref" href="#the-term-gil-is-tricky-for-free-threading" role="doc-backlink">The term “GIL” is tricky for free-threading</a></h4>
<p>A large issue with the term “GIL” in the C API is that it is semantically
misleading. This was noted in <a class="reference external" href="https://github.com/python/cpython/issues/127989">python/cpython#127989</a>,
created by the authors of this PEP:</p>
<blockquote>
<div>The biggest issue is that for free-threading, there is no GIL, so users
erroneously call the C API inside <code class="docutils literal notranslate"><span class="pre">Py_BEGIN_ALLOW_THREADS</span></code> blocks or
omit <code class="docutils literal notranslate"><span class="pre">PyGILState_Ensure</span></code> in fresh threads.</div></blockquote>
<p>Since Python 3.12, it is an <a class="reference external" href="https://docs.python.org/3.14/glossary.html#term-attached-thread-state" title="(in Python v3.14)"><span class="xref std std-term">attached thread state</span></a> that lets a thread
invoke the C API. On with-GIL builds, holding an attached thread state
implies holding the GIL, so only one thread can have one at a time. Free-threaded
builds achieve the effect of multi-core parallism while remaining
ackwards-compatible by simply removing that limitation: threads still need a
thread state (and thus need to call <a class="reference external" href="https://docs.python.org/3/c-api/init.html#c.PyGILState_Ensure" title="(in Python v3.13)"><code class="xref c c-func docutils literal notranslate"><span class="pre">PyGILState_Ensure()</span></code></a>), but they
don’t need to wait on one another to do so.</p>
</section>
</section>
<section id="subinterpreters-don-t-work-with-pygilstate-ensure">
<h3><a class="toc-backref" href="#subinterpreters-don-t-work-with-pygilstate-ensure" role="doc-backlink">Subinterpreters don’t work with <code class="docutils literal notranslate"><span class="pre">PyGILState_Ensure</span></code></a></h3>
<p>As noted in the <a class="reference external" href="https://docs.python.org/3/c-api/init.html#gilstate" title="(in Python v3.13)"><span class="xref std std-ref">documentation</span></a>,
<code class="docutils literal notranslate"><span class="pre">PyGILState</span></code> APIs aren’t officially supported in subinterpreters:</p>
<blockquote>
<div>Note that the <code class="docutils literal notranslate"><span class="pre">PyGILState_*</span></code> functions assume there is only one global
interpreter (created automatically by <code class="docutils literal notranslate"><span class="pre">Py_Initialize()</span></code>). Python
supports the creation of additional interpreters (using
<code class="docutils literal notranslate"><span class="pre">Py_NewInterpreter()</span></code>), but mixing multiple interpreters and the
<code class="docutils literal notranslate"><span class="pre">PyGILState_*</span></code> API is unsupported.</div></blockquote>
<p>More technically, this is because <code class="docutils literal notranslate"><span class="pre">PyGILState_Ensure</span></code> doesn’t have any way
to know which interpreter created the thread, and as such, it has to assume
that it was the main interpreter. There isn’t any way to detect this at
runtime, so spurious races are bound to come up in threads created by
subinterpreters, because synchronization for the wrong interpreter will be
used on objects shared between the threads.</p>
<section id="interpreters-can-concurrently-shut-down">
<h4><a class="toc-backref" href="#interpreters-can-concurrently-shut-down" role="doc-backlink">Interpreters can concurrently shut down</a></h4>
<p>The other way of creating a native thread that can invoke Python,
<a class="reference external" href="https://docs.python.org/3/c-api/init.html#c.PyThreadState_New" title="(in Python v3.13)"><code class="xref c c-func docutils literal notranslate"><span class="pre">PyThreadState_New()</span></code></a> / <a class="reference external" href="https://docs.python.org/3/c-api/init.html#c.PyThreadState_Swap" title="(in Python v3.13)"><code class="xref c c-func docutils literal notranslate"><span class="pre">PyThreadState_Swap()</span></code></a>, is a lot better
for supporting subinterpreters (because <a class="reference external" href="https://docs.python.org/3/c-api/init.html#c.PyThreadState_New" title="(in Python v3.13)"><code class="xref c c-func docutils literal notranslate"><span class="pre">PyThreadState_New()</span></code></a> takes an
explicit interpreter, rather than assuming that the main interpreter was intended),
but is still limited by the current API.</p>
<p>In particular, subinterpreters typically have a much shorter lifetime than the
main interpreter, and as such, there’s not necessarily a guarantee that a
<a class="reference external" href="https://docs.python.org/3/c-api/init.html#c.PyInterpreterState" title="(in Python v3.13)"><code class="xref c c-type docutils literal notranslate"><span class="pre">PyInterpreterState</span></code></a> (acquired by <a class="reference external" href="https://docs.python.org/3/c-api/init.html#c.PyInterpreterState_Get" title="(in Python v3.13)"><code class="xref c c-func docutils literal notranslate"><span class="pre">PyInterpreterState_Get()</span></code></a>)
passed to a fresh thread will still be alive. Similarly, a
<a class="reference external" href="https://docs.python.org/3/c-api/init.html#c.PyInterpreterState" title="(in Python v3.13)"><code class="xref c c-type docutils literal notranslate"><span class="pre">PyInterpreterState</span></code></a> pointer could have been replaced with a <em>new</em>
interpreter, causing all sorts of unknown issues. They are also subject to
all the finalization related hanging mentioned previously.</p>
</section>
</section>
</section>
<section id="rationale">
<h2><a class="toc-backref" href="#rationale" role="doc-backlink">Rationale</a></h2>
<p>This PEP includes several new APIs that intend to fix all of the issues stated
above.</p>
<section id="replacing-the-old-apis">
<h3><a class="toc-backref" href="#replacing-the-old-apis" role="doc-backlink">Replacing the old APIs</a></h3>
<p>As made clear in <a class="reference internal" href="#motivation">Motivation</a>, <code class="docutils literal notranslate"><span class="pre">PyGILState</span></code> is already pretty buggy, and
even if it was magically fixed, the current behavior of hanging the thread is
beyond repair. In turn, this PEP intends to completely deprecate the existing
<code class="docutils literal notranslate"><span class="pre">PyGILState</span></code> APIs and provide better alternatives. However, even if this PEP
is rejected, all of the APIs can be replaced with more correct <code class="docutils literal notranslate"><span class="pre">PyThreadState</span></code>
functions in the current C API:</p>
<ul class="simple">
<li><a class="reference external" href="https://docs.python.org/3/c-api/init.html#c.PyGILState_Ensure" title="(in Python v3.13)"><code class="xref c c-func docutils literal notranslate"><span class="pre">PyGILState_Ensure()</span></code></a>: <a class="reference external" href="https://docs.python.org/3/c-api/init.html#c.PyThreadState_Swap" title="(in Python v3.13)"><code class="xref c c-func docutils literal notranslate"><span class="pre">PyThreadState_Swap()</span></code></a> &amp; <a class="reference external" href="https://docs.python.org/3/c-api/init.html#c.PyThreadState_New" title="(in Python v3.13)"><code class="xref c c-func docutils literal notranslate"><span class="pre">PyThreadState_New()</span></code></a></li>
<li><a class="reference external" href="https://docs.python.org/3/c-api/init.html#c.PyGILState_Release" title="(in Python v3.13)"><code class="xref c c-func docutils literal notranslate"><span class="pre">PyGILState_Release()</span></code></a>: <a class="reference external" href="https://docs.python.org/3/c-api/init.html#c.PyThreadState_Clear" title="(in Python v3.13)"><code class="xref c c-func docutils literal notranslate"><span class="pre">PyThreadState_Clear()</span></code></a> &amp; <a class="reference external" href="https://docs.python.org/3/c-api/init.html#c.PyThreadState_Delete" title="(in Python v3.13)"><code class="xref c c-func docutils literal notranslate"><span class="pre">PyThreadState_Delete()</span></code></a></li>
<li><a class="reference external" href="https://docs.python.org/3/c-api/init.html#c.PyGILState_GetThisThreadState" title="(in Python v3.13)"><code class="xref c c-func docutils literal notranslate"><span class="pre">PyGILState_GetThisThreadState()</span></code></a>: <a class="reference external" href="https://docs.python.org/3/c-api/init.html#c.PyThreadState_Get" title="(in Python v3.13)"><code class="xref c c-func docutils literal notranslate"><span class="pre">PyThreadState_Get()</span></code></a></li>
<li><a class="reference external" href="https://docs.python.org/3/c-api/init.html#c.PyGILState_Check" title="(in Python v3.13)"><code class="xref c c-func docutils literal notranslate"><span class="pre">PyGILState_Check()</span></code></a>: <code class="docutils literal notranslate"><span class="pre">PyThreadState_GetUnchecked()</span> <span class="pre">!=</span> <span class="pre">NULL</span></code></li>
</ul>
<p>This PEP specifies a ten-year deprecation for these functions (while remaining
in the stable ABI), primarily because it’s expected that the migration won’t be
seamless, due to the new requirement of storing an interpreter state. The
exact details of this deprecation are currently unclear, see
<a class="reference internal" href="#pep-788-deprecation"><span class="std std-ref">When should the legacy APIs be removed?</span></a>.</p>
</section>
<section id="a-light-layer-of-magic">
<h3><a class="toc-backref" href="#a-light-layer-of-magic" role="doc-backlink">A light layer of magic</a></h3>
<p>The APIs proposed by this PEP intentionally have a layer of abstraction that is
hidden from the user and offloads complexity onto CPython. This is done
primarily to help ease the transition from <code class="docutils literal notranslate"><span class="pre">PyGILState</span></code> for existing
codebases, and for ease-of-use to those who provide wrappers the C API, such
as Cython or PyO3.</p>
<p>In particular, the API hides details about the lifetime of the thread state
and most of the details with interpreter references.</p>
<p>See also <a class="reference internal" href="#pep-788-activate-deactivate-instead"><span class="std std-ref">Exposing an Activate/Deactivate API instead of Ensure/Clear</span></a>.</p>
</section>
<section id="bikeshedding-and-the-pythreadstate-namespace">
<h3><a class="toc-backref" href="#bikeshedding-and-the-pythreadstate-namespace" role="doc-backlink">Bikeshedding and the <code class="docutils literal notranslate"><span class="pre">PyThreadState</span></code> namespace</a></h3>
<p>To solve the issue with “GIL” terminology, the new functions described by this
PEP intended as replacements for <code class="docutils literal notranslate"><span class="pre">PyGILState</span></code> will go under the existing
<code class="docutils literal notranslate"><span class="pre">PyThreadState</span></code> namespace. In Python 3.14, the documentation has been
updated to switch over to terms like
<a class="reference external" href="https://docs.python.org/3.14/glossary.html#term-attached-thread-state" title="(in Python v3.14)"><span class="xref std std-term">“attached thread state”</span></a> instead of
<a class="reference external" href="https://docs.python.org/3/glossary.html#term-global-interpreter-lock" title="(in Python v3.13)"><span class="xref std std-term">“global interpreter lock”</span></a>, so this namespace
seems to fit well for this PEP.</p>
</section>
<section id="preventing-interpreter-finalization-with-references">
<h3><a class="toc-backref" href="#preventing-interpreter-finalization-with-references" role="doc-backlink">Preventing interpreter finalization with references</a></h3>
<p>Several iterations of this API have taken an approach where
<a class="reference internal" href="#c.PyThreadState_Ensure" title="PyThreadState_Ensure"><code class="xref c c-func docutils literal notranslate"><span class="pre">PyThreadState_Ensure()</span></code></a> can return a failure based on the state of
the interpreter. Instead, this PEP takes an approach where an interpreter
keeps track of the number of non-daemon threads, which inherently prevents
it from beginning finalization.</p>
<p>The main upside with this approach is that there’s more consistency with
attaching threads. Using an interpreter reference from the calling thread
keeps the interpreter from finalizing before the thread starts, ensuring
that it always works. An approach that were to return a failure based on
the start-time of the thread could cause spurious issues.</p>
<p>In the case where it is useful to let the interpreter finalize, such as in
an asynchronous callback where there’s no guarantee that the thread will start,
strong references to an interpreter can be acquired through
<a class="reference internal" href="#c.PyInterpreterState_Lookup" title="PyInterpreterState_Lookup"><code class="xref c c-func docutils literal notranslate"><span class="pre">PyInterpreterState_Lookup()</span></code></a>.</p>
</section>
</section>
<section id="specification">
<h2><a class="toc-backref" href="#specification" role="doc-backlink">Specification</a></h2>
<section id="daemon-and-non-daemon-threads">
<h3><a class="toc-backref" href="#daemon-and-non-daemon-threads" role="doc-backlink">Daemon and non-daemon threads</a></h3>
<p>This PEP introduces the concept of non-daemon thread states. By default, all
threads created without the <a class="reference external" href="https://docs.python.org/3/library/threading.html#module-threading" title="(in Python v3.13)"><code class="xref py py-mod docutils literal notranslate"><span class="pre">threading</span></code></a> module will hang when trying to
attach a thread state for a finalizing interpreter (in fact, daemon threads
that <em>are</em> created with the <a class="reference external" href="https://docs.python.org/3/library/threading.html#module-threading" title="(in Python v3.13)"><code class="xref py py-mod docutils literal notranslate"><span class="pre">threading</span></code></a> module will hang in the same
way). This generally happens when a thread calls <a class="reference external" href="https://docs.python.org/3/c-api/init.html#c.PyEval_RestoreThread" title="(in Python v3.13)"><code class="xref c c-func docutils literal notranslate"><span class="pre">PyEval_RestoreThread()</span></code></a>
or in between bytecode instructions, based on <a class="reference external" href="https://docs.python.org/3/library/sys.html#sys.setswitchinterval" title="(in Python v3.13)"><code class="xref py py-func docutils literal notranslate"><span class="pre">sys.setswitchinterval()</span></code></a>.</p>
<p>A new, internal field will be added to the <code class="docutils literal notranslate"><span class="pre">PyThreadState</span></code> structure that
determines if the thread is daemon. Before finalization, an interpreter
will wait until all non-daemon threads call <a class="reference external" href="https://docs.python.org/3/c-api/init.html#c.PyThreadState_Delete" title="(in Python v3.13)"><code class="xref c c-func docutils literal notranslate"><span class="pre">PyThreadState_Delete()</span></code></a>.</p>
<p>For backwards compatibility, all thread states created by existing APIs,
including <a class="reference external" href="https://docs.python.org/3/c-api/init.html#c.PyGILState_Ensure" title="(in Python v3.13)"><code class="xref c c-func docutils literal notranslate"><span class="pre">PyGILState_Ensure()</span></code></a>, will remain daemon by default.
See <a class="reference internal" href="#pep-788-hanging-compat"><span class="std std-ref">We can’t change finalization behavior for PyGILState_Ensure</span></a>.</p>
<dl class="c function">
<dt class="sig sig-object c" id="c.PyThreadState_SetDaemon">
<span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">PyThreadState_SetDaemon</span></span></span><span class="sig-paren">(</span><span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="n"><span class="pre">is_daemon</span></span><span class="sig-paren">)</span><br /></dt>
<dd>Set the <a class="reference external" href="https://docs.python.org/3.14/glossary.html#term-attached-thread-state" title="(in Python v3.14)"><span class="xref std std-term">attached thread state</span></a> as non-daemon or daemon.<p>The attached thread state must not be the main thread for the
interpreter. All thread states created without
<a class="reference internal" href="#c.PyThreadState_Ensure" title="PyThreadState_Ensure"><code class="xref c c-func docutils literal notranslate"><span class="pre">PyThreadState_Ensure()</span></code></a> are daemon by default.</p>
<p>If the thread state is non-daemon, then the current interpreter will wait
for this thread to finish before shutting down. See also
<a class="reference external" href="https://docs.python.org/3/library/threading.html#threading.Thread.daemon" title="(in Python v3.13)"><code class="xref py py-attr docutils literal notranslate"><span class="pre">threading.Thread.daemon</span></code></a>.</p>
<p>Return zero on success, non-zero <em>without</em> an exception set on failure.</p>
</dd></dl>

</section>
<section id="interpreter-reference-counting">
<h3><a class="toc-backref" href="#interpreter-reference-counting" role="doc-backlink">Interpreter reference counting</a></h3>
<p>Internally, an interpreter will have to keep track of the number of
non-daemon native threads, which will determine when an interpreter can
finalize. This is done to prevent use-after-free crashes in
<a class="reference internal" href="#c.PyThreadState_Ensure" title="PyThreadState_Ensure"><code class="xref c c-func docutils literal notranslate"><span class="pre">PyThreadState_Ensure()</span></code></a> for interpreters with short lifetimes, and
to remove needless layers of synchronization between the calling thread and
the started thread.</p>
<p>An interpreter state returned by <a class="reference external" href="https://docs.python.org/3/c-api/init.html#c.Py_NewInterpreter" title="(in Python v3.13)"><code class="xref c c-func docutils literal notranslate"><span class="pre">Py_NewInterpreter()</span></code></a> (or really,
<a class="reference external" href="https://docs.python.org/3/c-api/init.html#c.PyInterpreterState_New" title="(in Python v3.13)"><code class="xref c c-func docutils literal notranslate"><span class="pre">PyInterpreterState_New()</span></code></a>) will start with a native thread countdown.
For simplicity’s sake, this will be referred to as a reference count.
A non-zero reference count prevents the interpreter from finalizing.</p>
<dl class="c function">
<dt class="sig sig-object c" id="c.PyInterpreterState_Hold">
<a class="reference external" href="https://docs.python.org/3/c-api/init.html#c.PyInterpreterState" title="(in Python v3.13)"><span class="n"><span class="pre">PyInterpreterState</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="sig-name descname"><span class="n"><span class="pre">PyInterpreterState_Hold</span></span></span><span class="sig-paren">(</span><span class="kt"><span class="pre">void</span></span><span class="sig-paren">)</span><br /></dt>
<dd>Similar to <a class="reference external" href="https://docs.python.org/3/c-api/init.html#c.PyInterpreterState_Get" title="(in Python v3.13)"><code class="xref c c-func docutils literal notranslate"><span class="pre">PyInterpreterState_Get()</span></code></a>, but returns a strong
reference to the interpreter (meaning, it has its reference count
incremented by one, allowing the returned interpreter state to be safely
accessed by another thread, because it will be prevented from finalizing).<p>This function is generally meant to be used in tandem with
<a class="reference internal" href="#c.PyThreadState_Ensure" title="PyThreadState_Ensure"><code class="xref c c-func docutils literal notranslate"><span class="pre">PyThreadState_Ensure()</span></code></a>.</p>
<p>The caller must have an <a class="reference external" href="https://docs.python.org/3.14/glossary.html#term-attached-thread-state" title="(in Python v3.14)"><span class="xref std std-term">attached thread state</span></a>. This function
cannot return <code class="docutils literal notranslate"><span class="pre">NULL</span></code>. Failures are always a fatal error.</p>
</dd></dl>

<dl class="c function">
<dt class="sig sig-object c" id="c.PyInterpreterState_Lookup">
<a class="reference external" href="https://docs.python.org/3/c-api/init.html#c.PyInterpreterState" title="(in Python v3.13)"><span class="n"><span class="pre">PyInterpreterState</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="sig-name descname"><span class="n"><span class="pre">PyInterpreterState_Lookup</span></span></span><span class="sig-paren">(</span><span class="n"><span class="pre">int64_t</span></span><span class="w"> </span><span class="n"><span class="pre">interp_id</span></span><span class="sig-paren">)</span><br /></dt>
<dd>Similar to <a class="reference internal" href="#c.PyInterpreterState_Hold" title="PyInterpreterState_Hold"><code class="xref c c-func docutils literal notranslate"><span class="pre">PyInterpreterState_Hold()</span></code></a>, but looks up an interpreter
based on an ID (see <a class="reference external" href="https://docs.python.org/3/c-api/init.html#c.PyInterpreterState_GetID" title="(in Python v3.13)"><code class="xref c c-func docutils literal notranslate"><span class="pre">PyInterpreterState_GetID()</span></code></a>). This has the
benefit of allowing the interpreter to finalize in cases where the thread
might not start, such as inside of an asynchronous callback.<p>This function will return <code class="docutils literal notranslate"><span class="pre">NULL</span></code> without an exception set on failure.
If the return value is non-<code class="docutils literal notranslate"><span class="pre">NULL</span></code>, then the returned interpreter will be
prevented from finalizing until the reference is released by
<a class="reference internal" href="#c.PyThreadState_Release" title="PyThreadState_Release"><code class="xref c c-func docutils literal notranslate"><span class="pre">PyThreadState_Release()</span></code></a> or <a class="reference internal" href="#c.PyInterpreterState_Release" title="PyInterpreterState_Release"><code class="xref c c-func docutils literal notranslate"><span class="pre">PyInterpreterState_Release()</span></code></a>.</p>
<p>Returning <code class="docutils literal notranslate"><span class="pre">NULL</span></code> typically means that the interpreter is at a point
where threads cannot start, or no longer exists.</p>
<p>The caller does not need to have an <a class="reference external" href="https://docs.python.org/3.14/glossary.html#term-attached-thread-state" title="(in Python v3.14)"><span class="xref std std-term">attached thread state</span></a>.</p>
</dd></dl>

<dl class="c function">
<dt class="sig sig-object c" id="c.PyInterpreterState_Release">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">PyInterpreterState_Release</span></span></span><span class="sig-paren">(</span><a class="reference external" href="https://docs.python.org/3/c-api/init.html#c.PyInterpreterState" title="(in Python v3.13)"><span class="n"><span class="pre">PyInterpreterState</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">interp</span></span><span class="sig-paren">)</span><br /></dt>
<dd>Decrement the reference count of the interpreter, as was incremented by
<a class="reference internal" href="#c.PyInterpreterState_Hold" title="PyInterpreterState_Hold"><code class="xref c c-func docutils literal notranslate"><span class="pre">PyInterpreterState_Hold()</span></code></a> or <a class="reference internal" href="#c.PyInterpreterState_Lookup" title="PyInterpreterState_Lookup"><code class="xref c c-func docutils literal notranslate"><span class="pre">PyInterpreterState_Lookup()</span></code></a>.<p>This function cannot fail, other than with a fatal error. The caller does
not need to have an <a class="reference external" href="https://docs.python.org/3.14/glossary.html#term-attached-thread-state" title="(in Python v3.14)"><span class="xref std std-term">attached thread state</span></a> for <em>interp</em>.</p>
</dd></dl>

</section>
<section id="ensuring-and-releasing-thread-states">
<h3><a class="toc-backref" href="#ensuring-and-releasing-thread-states" role="doc-backlink">Ensuring and releasing thread states</a></h3>
<p>This proposal includes two new high-level threading APIs that intend to
replace <a class="reference external" href="https://docs.python.org/3/c-api/init.html#c.PyGILState_Ensure" title="(in Python v3.13)"><code class="xref c c-func docutils literal notranslate"><span class="pre">PyGILState_Ensure()</span></code></a> and <a class="reference external" href="https://docs.python.org/3/c-api/init.html#c.PyGILState_Release" title="(in Python v3.13)"><code class="xref c c-func docutils literal notranslate"><span class="pre">PyGILState_Release()</span></code></a>.</p>
<dl class="c function">
<dt class="sig sig-object c" id="c.PyThreadState_Ensure">
<span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">PyThreadState_Ensure</span></span></span><span class="sig-paren">(</span><a class="reference external" href="https://docs.python.org/3/c-api/init.html#c.PyInterpreterState" title="(in Python v3.13)"><span class="n"><span class="pre">PyInterpreterState</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">interp</span></span><span class="sig-paren">)</span><br /></dt>
<dd>Ensure that the thread has an <a class="reference external" href="https://docs.python.org/3.14/glossary.html#term-attached-thread-state" title="(in Python v3.14)"><span class="xref std std-term">attached thread state</span></a> for <em>interp</em>,
and thus can safely invoke that interpreter. It is OK to call this
function if the thread already has an attached thread state, as long as
there is a subsequent call to <a class="reference internal" href="#c.PyThreadState_Release" title="PyThreadState_Release"><code class="xref c c-func docutils literal notranslate"><span class="pre">PyThreadState_Release()</span></code></a> that matches
this one.<p>The reference to the interpreter <em>interp</em> is stolen by this function.
As such, <em>interp</em> should have been acquired by
<a class="reference internal" href="#c.PyInterpreterState_Hold" title="PyInterpreterState_Hold"><code class="xref c c-func docutils literal notranslate"><span class="pre">PyInterpreterState_Hold()</span></code></a>.</p>
<p>Thread states created by this function are non-daemon by default. See
<a class="reference internal" href="#c.PyThreadState_SetDaemon" title="PyThreadState_SetDaemon"><code class="xref c c-func docutils literal notranslate"><span class="pre">PyThreadState_SetDaemon()</span></code></a>. If the calling thread already has an
attached thread state that matches <em>interp</em>, then this function
will mark the existing thread state as non-daemon and return. It will
be restored to its prior daemon status upon the next
<a class="reference internal" href="#c.PyThreadState_Release" title="PyThreadState_Release"><code class="xref c c-func docutils literal notranslate"><span class="pre">PyThreadState_Release()</span></code></a> call.</p>
<p>Return zero on success, and non-zero with the old attached thread state
restored (which may have been <code class="docutils literal notranslate"><span class="pre">NULL</span></code>).</p>
</dd></dl>

<dl class="c function">
<dt class="sig sig-object c" id="c.PyThreadState_Release">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">PyThreadState_Release</span></span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><br /></dt>
<dd>Release the <a class="reference external" href="https://docs.python.org/3.14/glossary.html#term-attached-thread-state" title="(in Python v3.14)"><span class="xref std std-term">attached thread state</span></a> set by
<a class="reference internal" href="#c.PyThreadState_Ensure" title="PyThreadState_Ensure"><code class="xref c c-func docutils literal notranslate"><span class="pre">PyThreadState_Ensure()</span></code></a>. Any thread state that was set prior
to the original call to <a class="reference internal" href="#c.PyThreadState_Ensure" title="PyThreadState_Ensure"><code class="xref c c-func docutils literal notranslate"><span class="pre">PyThreadState_Ensure()</span></code></a> will be restored.<p>This function cannot fail, but may hang the thread if the
attached thread state prior to the original <code class="xref c c-func docutils literal notranslate"><span class="pre">PyThreadState_Ensure()</span></code>
was daemon and the interpreter was finalized.</p>
</dd></dl>

</section>
<section id="deprecation-of-pygilstate-apis">
<h3><a class="toc-backref" href="#deprecation-of-pygilstate-apis" role="doc-backlink">Deprecation of <code class="docutils literal notranslate"><span class="pre">PyGILState</span></code> APIs</a></h3>
<p>This PEP deprecates all of the existing <code class="docutils literal notranslate"><span class="pre">PyGILState</span></code> APIs in favor of the
new <code class="docutils literal notranslate"><span class="pre">PyThreadState</span></code> APIs for the reasons given in the <a class="reference internal" href="#motivation">Motivation</a>. Namely:</p>
<ul class="simple">
<li><a class="reference external" href="https://docs.python.org/3/c-api/init.html#c.PyGILState_Ensure" title="(in Python v3.13)"><code class="xref c c-func docutils literal notranslate"><span class="pre">PyGILState_Ensure()</span></code></a>: use <a class="reference internal" href="#c.PyThreadState_Ensure" title="PyThreadState_Ensure"><code class="xref c c-func docutils literal notranslate"><span class="pre">PyThreadState_Ensure()</span></code></a> instead.</li>
<li><a class="reference external" href="https://docs.python.org/3/c-api/init.html#c.PyGILState_Release" title="(in Python v3.13)"><code class="xref c c-func docutils literal notranslate"><span class="pre">PyGILState_Release()</span></code></a>: use <a class="reference internal" href="#c.PyThreadState_Release" title="PyThreadState_Release"><code class="xref c c-func docutils literal notranslate"><span class="pre">PyThreadState_Release()</span></code></a> instead.</li>
<li><a class="reference external" href="https://docs.python.org/3/c-api/init.html#c.PyGILState_GetThisThreadState" title="(in Python v3.13)"><code class="xref c c-func docutils literal notranslate"><span class="pre">PyGILState_GetThisThreadState()</span></code></a>: use <a class="reference external" href="https://docs.python.org/3/c-api/init.html#c.PyThreadState_Get" title="(in Python v3.13)"><code class="xref c c-func docutils literal notranslate"><span class="pre">PyThreadState_Get()</span></code></a> or
<a class="reference external" href="https://docs.python.org/3/c-api/init.html#c.PyThreadState_GetUnchecked" title="(in Python v3.13)"><code class="xref c c-func docutils literal notranslate"><span class="pre">PyThreadState_GetUnchecked()</span></code></a> instead.</li>
<li><a class="reference external" href="https://docs.python.org/3/c-api/init.html#c.PyGILState_Check" title="(in Python v3.13)"><code class="xref c c-func docutils literal notranslate"><span class="pre">PyGILState_Check()</span></code></a>: use <code class="docutils literal notranslate"><span class="pre">PyThreadState_GetUnchecked()</span> <span class="pre">!=</span> <span class="pre">NULL</span></code>
instead.</li>
</ul>
<p>All of the <code class="docutils literal notranslate"><span class="pre">PyGILState</span></code> APIs are to be removed from the non-limited C API in
Python 3.25. They will remain available in the stable ABI for compatibility.</p>
</section>
</section>
<section id="backwards-compatibility">
<h2><a class="toc-backref" href="#backwards-compatibility" role="doc-backlink">Backwards Compatibility</a></h2>
<p>This PEP specifies a breaking change with the removal of all the
<code class="docutils literal notranslate"><span class="pre">PyGILState</span></code> APIs from the public headers of the non-limited C API in 10
years (Python 3.25).</p>
</section>
<section id="security-implications">
<h2><a class="toc-backref" href="#security-implications" role="doc-backlink">Security Implications</a></h2>
<p>This PEP has no known security implications.</p>
</section>
<section id="how-to-teach-this">
<h2><a class="toc-backref" href="#how-to-teach-this" role="doc-backlink">How to Teach This</a></h2>
<p>As with all C API functions, all the new APIs in this PEP will be documented
in the C API documentation, ideally under the <a class="reference external" href="https://docs.python.org/3/c-api/init.html#gilstate" title="(in Python v3.13)"><span>Non-Python created threads</span></a> section.
The existing <code class="docutils literal notranslate"><span class="pre">PyGILState</span></code> documentation should be updated accordingly to point
to the new APIs.</p>
<section id="examples">
<h3><a class="toc-backref" href="#examples" role="doc-backlink">Examples</a></h3>
<p>These examples are here to help understand the APIs described in this PEP.
Ideally, they could be reused in the documentation.</p>
<section id="single-threaded-example">
<h4><a class="toc-backref" href="#single-threaded-example" role="doc-backlink">Single-threaded example</a></h4>
<p>This example shows acquiring a lock in a Python method.</p>
<p>If this were to be called from a daemon thread, then the interpreter could
hang the thread while reattaching the thread state, leaving us with the lock
held. Any future finalizer that wanted to acquire the lock would be deadlocked!</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="k">static</span><span class="w"> </span><span class="n">PyObject</span><span class="w"> </span><span class="o">*</span>
<span class="nf">my_critical_operation</span><span class="p">(</span><span class="n">PyObject</span><span class="w"> </span><span class="o">*</span><span class="n">self</span><span class="p">,</span><span class="w"> </span><span class="n">PyObject</span><span class="w"> </span><span class="o">*</span><span class="n">unused</span><span class="p">)</span>
<span class="p">{</span>
<span class="w">    </span><span class="n">assert</span><span class="p">(</span><span class="n">PyThreadState_GetUnchecked</span><span class="p">()</span><span class="w"> </span><span class="o">!=</span><span class="w"> </span><span class="nb">NULL</span><span class="p">);</span>
<span class="w">    </span><span class="n">PyInterpreterState</span><span class="w"> </span><span class="o">*</span><span class="n">interp</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">PyInterpreterState_Hold</span><span class="p">();</span>
<span class="w">    </span><span class="cm">/* Temporarily make this thread non-daemon to ensure that the</span>
<span class="cm">       lock is released. */</span>
<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">PyThreadState_Ensure</span><span class="p">(</span><span class="n">interp</span><span class="p">)</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="mi">0</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="n">PyErr_SetString</span><span class="p">(</span><span class="n">PyExc_PythonFinalizationError</span><span class="p">,</span>
<span class="w">                        </span><span class="s">&quot;interpreter is shutting down&quot;</span><span class="p">);</span>
<span class="w">        </span><span class="k">return</span><span class="w"> </span><span class="nb">NULL</span><span class="p">;</span>
<span class="w">    </span><span class="p">}</span>

<span class="w">    </span><span class="n">Py_BEGIN_ALLOW_THREADS</span><span class="p">;</span>
<span class="w">    </span><span class="n">acquire_some_lock</span><span class="p">();</span>
<span class="w">    </span><span class="n">Py_END_ALLOW_THREADS</span><span class="p">;</span>

<span class="w">    </span><span class="cm">/* Do something while holding the lock */</span>
<span class="w">    </span><span class="c1">// ...</span>

<span class="w">    </span><span class="n">release_some_lock</span><span class="p">();</span>
<span class="w">    </span><span class="n">PyThreadState_Release</span><span class="p">();</span>
<span class="w">    </span><span class="n">Py_RETURN_NONE</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
</section>
<section id="transitioning-from-old-functions">
<h4><a class="toc-backref" href="#transitioning-from-old-functions" role="doc-backlink">Transitioning from old functions</a></h4>
<p>The following code uses the old <code class="docutils literal notranslate"><span class="pre">PyGILState</span></code> APIs:</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="k">static</span><span class="w"> </span><span class="kt">int</span>
<span class="nf">thread_func</span><span class="p">(</span><span class="kt">void</span><span class="w"> </span><span class="o">*</span><span class="n">arg</span><span class="p">)</span>
<span class="p">{</span>
<span class="w">    </span><span class="n">PyGILState_STATE</span><span class="w"> </span><span class="n">gstate</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">PyGILState_Ensure</span><span class="p">();</span>
<span class="w">    </span><span class="cm">/* It&#39;s not an issue in this example, but we just attached</span>
<span class="cm">       a thread state for the main interpreter. If my_method() was</span>
<span class="cm">       originally called in a subinterpreter, then we would be unable</span>
<span class="cm">       to safely interact with any objects from it. */</span>
<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">PyRun_SimpleString</span><span class="p">(</span><span class="s">&quot;print(42)&quot;</span><span class="p">)</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="mi">0</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="n">PyErr_Print</span><span class="p">();</span>
<span class="w">    </span><span class="p">}</span>
<span class="w">    </span><span class="n">PyGILState_Release</span><span class="p">(</span><span class="n">gstate</span><span class="p">);</span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span><span class="w"> </span><span class="n">PyObject</span><span class="w"> </span><span class="o">*</span>
<span class="nf">my_method</span><span class="p">(</span><span class="n">PyObject</span><span class="w"> </span><span class="o">*</span><span class="n">self</span><span class="p">,</span><span class="w"> </span><span class="n">PyObject</span><span class="w"> </span><span class="o">*</span><span class="n">unused</span><span class="p">)</span>
<span class="p">{</span>
<span class="w">    </span><span class="n">PyThread_handle_t</span><span class="w"> </span><span class="n">handle</span><span class="p">;</span>
<span class="w">    </span><span class="n">PyThead_indent_t</span><span class="w"> </span><span class="n">indent</span><span class="p">;</span>

<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">PyThread_start_joinable_thread</span><span class="p">(</span><span class="n">thread_func</span><span class="p">,</span><span class="w"> </span><span class="nb">NULL</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">ident</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">handle</span><span class="p">)</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="mi">0</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="k">return</span><span class="w"> </span><span class="nb">NULL</span><span class="p">;</span>
<span class="w">    </span><span class="p">}</span>
<span class="w">    </span><span class="n">Py_BEGIN_ALLOW_THREADS</span><span class="p">;</span>
<span class="w">    </span><span class="n">PyThread_join_thread</span><span class="p">(</span><span class="n">handle</span><span class="p">);</span>
<span class="w">    </span><span class="n">Py_END_ALLOW_THREADS</span><span class="p">;</span>
<span class="w">    </span><span class="n">Py_RETURN_NONE</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
<p>This is the same code, updated to use the new functions:</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="k">static</span><span class="w"> </span><span class="kt">int</span>
<span class="nf">thread_func</span><span class="p">(</span><span class="kt">void</span><span class="w"> </span><span class="o">*</span><span class="n">arg</span><span class="p">)</span>
<span class="p">{</span>
<span class="w">    </span><span class="n">PyInterpreterState</span><span class="w"> </span><span class="o">*</span><span class="n">interp</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="n">PyInterpreterState</span><span class="w"> </span><span class="o">*</span><span class="p">)</span><span class="n">arg</span><span class="p">;</span>
<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">PyThreadState_Ensure</span><span class="p">(</span><span class="n">interp</span><span class="p">)</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="mi">0</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="n">fputs</span><span class="p">(</span><span class="s">&quot;Cannot talk to Python&quot;</span><span class="p">,</span><span class="w"> </span><span class="n">stderr</span><span class="p">);</span>
<span class="w">        </span><span class="k">return</span><span class="w"> </span><span class="mi">-1</span><span class="p">;</span>
<span class="w">    </span><span class="p">}</span>
<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">PyRun_SimpleString</span><span class="p">(</span><span class="s">&quot;print(42)&quot;</span><span class="p">)</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="mi">0</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="n">PyErr_Print</span><span class="p">();</span>
<span class="w">    </span><span class="p">}</span>
<span class="w">    </span><span class="n">PyThreadState_Release</span><span class="p">();</span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span><span class="w"> </span><span class="n">PyObject</span><span class="w"> </span><span class="o">*</span>
<span class="nf">my_method</span><span class="p">(</span><span class="n">PyObject</span><span class="w"> </span><span class="o">*</span><span class="n">self</span><span class="p">,</span><span class="w"> </span><span class="n">PyObject</span><span class="w"> </span><span class="o">*</span><span class="n">unused</span><span class="p">)</span>
<span class="p">{</span>
<span class="w">    </span><span class="n">PyThread_handle_t</span><span class="w"> </span><span class="n">handle</span><span class="p">;</span>
<span class="w">    </span><span class="n">PyThead_indent_t</span><span class="w"> </span><span class="n">indent</span><span class="p">;</span>

<span class="w">    </span><span class="n">PyInterpreterState</span><span class="w"> </span><span class="o">*</span><span class="n">interp</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">PyInterpreterState_Hold</span><span class="p">();</span>
<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">PyThread_start_joinable_thread</span><span class="p">(</span><span class="n">thread_func</span><span class="p">,</span><span class="w"> </span><span class="n">interp</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">ident</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">handle</span><span class="p">)</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="mi">0</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="n">PyInterpreterState_Release</span><span class="p">(</span><span class="n">interp</span><span class="p">);</span>
<span class="w">        </span><span class="k">return</span><span class="w"> </span><span class="nb">NULL</span><span class="p">;</span>
<span class="w">    </span><span class="p">}</span>
<span class="w">    </span><span class="n">Py_BEGIN_ALLOW_THREADS</span>
<span class="w">    </span><span class="n">PyThread_join_thread</span><span class="p">(</span><span class="n">handle</span><span class="p">);</span>
<span class="w">    </span><span class="n">Py_END_ALLOW_THREADS</span>
<span class="w">    </span><span class="n">Py_RETURN_NONE</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
</section>
<section id="daemon-thread-example">
<h4><a class="toc-backref" href="#daemon-thread-example" role="doc-backlink">Daemon thread example</a></h4>
<p>Native daemon threads are still a use-case, and as such,
they can still be used with this API:</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="k">static</span><span class="w"> </span><span class="kt">int</span>
<span class="nf">thread_func</span><span class="p">(</span><span class="kt">void</span><span class="w"> </span><span class="o">*</span><span class="n">arg</span><span class="p">)</span>
<span class="p">{</span>
<span class="w">    </span><span class="n">PyInterpreterState</span><span class="w"> </span><span class="o">*</span><span class="n">interp</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="n">PyInterpreterState</span><span class="w"> </span><span class="o">*</span><span class="p">)</span><span class="n">arg</span><span class="p">;</span>
<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">PyThreadState_Ensure</span><span class="p">(</span><span class="n">interp</span><span class="p">)</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="mi">0</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="n">fputs</span><span class="p">(</span><span class="s">&quot;Cannot talk to Python&quot;</span><span class="p">,</span><span class="w"> </span><span class="n">stderr</span><span class="p">);</span>
<span class="w">        </span><span class="k">return</span><span class="w"> </span><span class="mi">-1</span><span class="p">;</span>
<span class="w">    </span><span class="p">}</span>
<span class="w">    </span><span class="p">(</span><span class="kt">void</span><span class="p">)</span><span class="n">PyThreadState_SetDaemon</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>
<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">PyRun_SimpleString</span><span class="p">(</span><span class="s">&quot;print(42)&quot;</span><span class="p">)</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="mi">0</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="n">PyErr_Print</span><span class="p">();</span>
<span class="w">    </span><span class="p">}</span>
<span class="w">    </span><span class="n">PyThreadState_Release</span><span class="p">();</span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span><span class="w"> </span><span class="n">PyObject</span><span class="w"> </span><span class="o">*</span>
<span class="nf">my_method</span><span class="p">(</span><span class="n">PyObject</span><span class="w"> </span><span class="o">*</span><span class="n">self</span><span class="p">,</span><span class="w"> </span><span class="n">PyObject</span><span class="w"> </span><span class="o">*</span><span class="n">unused</span><span class="p">)</span>
<span class="p">{</span>
<span class="w">    </span><span class="n">PyThread_handle_t</span><span class="w"> </span><span class="n">handle</span><span class="p">;</span>
<span class="w">    </span><span class="n">PyThead_indent_t</span><span class="w"> </span><span class="n">indent</span><span class="p">;</span>

<span class="w">    </span><span class="n">PyInterpreterState</span><span class="w"> </span><span class="o">*</span><span class="n">interp</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">PyInterpreterState_Hold</span><span class="p">();</span>
<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">PyThread_start_joinable_thread</span><span class="p">(</span><span class="n">thread_func</span><span class="p">,</span><span class="w"> </span><span class="n">interp</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">ident</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">handle</span><span class="p">)</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="mi">0</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="n">PyInterpreterState_Release</span><span class="p">(</span><span class="n">interp</span><span class="p">);</span>
<span class="w">        </span><span class="k">return</span><span class="w"> </span><span class="nb">NULL</span><span class="p">;</span>
<span class="w">    </span><span class="p">}</span>
<span class="w">    </span><span class="n">Py_RETURN_NONE</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
</section>
<section id="asynchronous-callback-example">
<h4><a class="toc-backref" href="#asynchronous-callback-example" role="doc-backlink">Asynchronous callback example</a></h4>
<p>As stated in the <a class="reference internal" href="#motivation">Motivation</a>, there are many cases where it’s desirable
to call Python in an asynchronous callback. In such cases, it’s not safe to
call <a class="reference internal" href="#c.PyInterpreterState_Hold" title="PyInterpreterState_Hold"><code class="xref c c-func docutils literal notranslate"><span class="pre">PyInterpreterState_Hold()</span></code></a>, because it’s not guaranteed that
<a class="reference internal" href="#c.PyThreadState_Ensure" title="PyThreadState_Ensure"><code class="xref c c-func docutils literal notranslate"><span class="pre">PyThreadState_Ensure()</span></code></a> will ever be called.
If not, finalization becomes deadlocked.</p>
<p>This scenario requires using <a class="reference internal" href="#c.PyInterpreterState_Lookup" title="PyInterpreterState_Lookup"><code class="xref c c-func docutils literal notranslate"><span class="pre">PyInterpreterState_Lookup()</span></code></a> instead,
which only prevents finalization once the lookup has been made.</p>
<p>For example:</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="k">typedef</span><span class="w"> </span><span class="k">struct</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="kt">int64_t</span><span class="w"> </span><span class="n">interp_id</span><span class="p">;</span>
<span class="p">}</span><span class="w"> </span><span class="n">pyrun_t</span><span class="p">;</span>

<span class="k">static</span><span class="w"> </span><span class="kt">int</span>
<span class="nf">async_callback</span><span class="p">(</span><span class="kt">void</span><span class="w"> </span><span class="o">*</span><span class="n">arg</span><span class="p">)</span>
<span class="p">{</span>
<span class="w">    </span><span class="n">pyrun_t</span><span class="w"> </span><span class="o">*</span><span class="n">data</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="n">pyrun_t</span><span class="w"> </span><span class="o">*</span><span class="p">)</span><span class="n">arg</span><span class="p">;</span>
<span class="w">    </span><span class="n">PyInterpreterState</span><span class="w"> </span><span class="o">*</span><span class="n">interp</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">PyInterpreterState_Lookup</span><span class="p">(</span><span class="n">data</span><span class="o">-&gt;</span><span class="n">interp_id</span><span class="p">);</span>
<span class="w">    </span><span class="n">PyMem_RawFree</span><span class="p">(</span><span class="n">data</span><span class="p">);</span>
<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">interp</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="nb">NULL</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="n">fputs</span><span class="p">(</span><span class="s">&quot;Python has shut down&quot;</span><span class="p">,</span><span class="w"> </span><span class="n">stderr</span><span class="p">);</span>
<span class="w">        </span><span class="k">return</span><span class="w"> </span><span class="mi">-1</span><span class="p">;</span>
<span class="w">    </span><span class="p">}</span>
<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">PyThreadState_Ensure</span><span class="p">(</span><span class="n">interp</span><span class="p">)</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="mi">0</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="n">fputs</span><span class="p">(</span><span class="s">&quot;Cannot talk to Python&quot;</span><span class="p">,</span><span class="w"> </span><span class="n">stderr</span><span class="p">);</span>
<span class="w">        </span><span class="k">return</span><span class="w"> </span><span class="mi">-1</span><span class="p">;</span>
<span class="w">    </span><span class="p">}</span>
<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">PyRun_SimpleString</span><span class="p">(</span><span class="s">&quot;print(42)&quot;</span><span class="p">)</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="mi">0</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="n">PyErr_Print</span><span class="p">();</span>
<span class="w">    </span><span class="p">}</span>
<span class="w">    </span><span class="n">PyThreadState_Release</span><span class="p">();</span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span><span class="w"> </span><span class="n">PyObject</span><span class="w"> </span><span class="o">*</span>
<span class="nf">setup_callback</span><span class="p">(</span><span class="n">PyObject</span><span class="w"> </span><span class="o">*</span><span class="n">self</span><span class="p">,</span><span class="w"> </span><span class="n">PyObject</span><span class="w"> </span><span class="o">*</span><span class="n">unused</span><span class="p">)</span>
<span class="p">{</span>
<span class="w">    </span><span class="n">PyThread_handle_t</span><span class="w"> </span><span class="n">handle</span><span class="p">;</span>
<span class="w">    </span><span class="n">PyThead_indent_t</span><span class="w"> </span><span class="n">indent</span><span class="p">;</span>

<span class="w">    </span><span class="n">pyrun_t</span><span class="w"> </span><span class="o">*</span><span class="n">data</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">PyMem_RawMalloc</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="n">pyrun_t</span><span class="p">));</span>
<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">data</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="nb">NULL</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="k">return</span><span class="w"> </span><span class="n">PyErr_NoMemory</span><span class="p">();</span>
<span class="w">    </span><span class="p">}</span>
<span class="w">    </span><span class="c1">// Weak reference to the interpreter. It won&#39;t wait on the callback</span>
<span class="w">    </span><span class="c1">// to finalize.</span>
<span class="w">    </span><span class="n">data</span><span class="o">-&gt;</span><span class="n">interp_id</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">PyInterpreterState_GetID</span><span class="p">(</span><span class="n">PyInterpreterState_Get</span><span class="p">());</span>
<span class="w">    </span><span class="n">register_callback</span><span class="p">(</span><span class="n">async_callback</span><span class="p">,</span><span class="w"> </span><span class="n">data</span><span class="p">);</span>

<span class="w">    </span><span class="n">Py_RETURN_NONE</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
</section>
</section>
</section>
<section id="reference-implementation">
<h2><a class="toc-backref" href="#reference-implementation" role="doc-backlink">Reference Implementation</a></h2>
<p>A reference implementation of this PEP can be found
<a class="reference external" href="https://github.com/ZeroIntensity/cpython/tree/pep-788-impl">here</a>.</p>
</section>
<section id="rejected-ideas">
<h2><a class="toc-backref" href="#rejected-ideas" role="doc-backlink">Rejected Ideas</a></h2>
<section id="using-an-interpreter-id-instead-of-a-interpreter-state-for-pythreadstate-ensure">
<h3><a class="toc-backref" href="#using-an-interpreter-id-instead-of-a-interpreter-state-for-pythreadstate-ensure" role="doc-backlink">Using an interpreter ID instead of a interpreter state for <code class="docutils literal notranslate"><span class="pre">PyThreadState_Ensure</span></code></a></h3>
<p>Some iterations of this API took an <code class="docutils literal notranslate"><span class="pre">int64_t</span> <span class="pre">interp_id</span></code> parameter instead of
<code class="docutils literal notranslate"><span class="pre">PyInterpreterState</span> <span class="pre">*interp</span></code>, because interpreter IDs cannot be concurrently
deleted and cause use-after-free violations. <a class="reference internal" href="#c.PyInterpreterState_Hold" title="PyInterpreterState_Hold"><code class="xref c c-func docutils literal notranslate"><span class="pre">PyInterpreterState_Hold()</span></code></a>
fixes this issue anyway, but an interpreter ID does have the benefit of
requiring less magic in the implementation, but has several downsides:</p>
<ul class="simple">
<li>Nearly all existing interpreter APIs already return a <a class="reference external" href="https://docs.python.org/3/c-api/init.html#c.PyInterpreterState" title="(in Python v3.13)"><code class="xref c c-type docutils literal notranslate"><span class="pre">PyInterpreterState</span></code></a>
pointer, not an interpreter ID. Functions like
<a class="reference external" href="https://docs.python.org/3/c-api/init.html#c.PyThreadState_GetInterpreter" title="(in Python v3.13)"><code class="xref c c-func docutils literal notranslate"><span class="pre">PyThreadState_GetInterpreter()</span></code></a> would have to be accompanied by
frustrating calls to <a class="reference external" href="https://docs.python.org/3/c-api/init.html#c.PyInterpreterState_GetID" title="(in Python v3.13)"><code class="xref c c-func docutils literal notranslate"><span class="pre">PyInterpreterState_GetID()</span></code></a>. There’s also
no existing way to go from an <code class="docutils literal notranslate"><span class="pre">int64_t</span></code> back to a
<span class="c-expr sig sig-inline c"><a class="reference external" href="https://docs.python.org/3/c-api/init.html#c.PyInterpreterState" title="(in Python v3.13)"><span class="n">PyInterpreterState</span></a><span class="p">*</span></span>, and providing such an API would come
with its own set of design problems.</li>
<li>Threads typically take a <code class="docutils literal notranslate"><span class="pre">void</span> <span class="pre">*arg</span></code> parameter, not an <code class="docutils literal notranslate"><span class="pre">int64_t</span> <span class="pre">arg</span></code>.
As such, passing an interpreter pointer requires much less boilerplate
for the user, because an additional structure definition or heap allocation
would be needed to store the interpreter ID. This is especially an issue
on 32-bit systems, where <code class="docutils literal notranslate"><span class="pre">void</span> <span class="pre">*</span></code> is too small for an <code class="docutils literal notranslate"><span class="pre">int64_t</span></code>.</li>
<li>To retain usability, interpreter ID APIs would still need to keep a
reference count, otherwise the interpreter could be finalizing before
the native thread gets a chance to attach. The problem with using an
interpreter ID is that the reference count has to be “invisible”; it
must be tracked elsewhere in the interpreter, likely being <em>more</em>
complex than <a class="reference internal" href="#c.PyInterpreterState_Hold" title="PyInterpreterState_Hold"><code class="xref c c-func docutils literal notranslate"><span class="pre">PyInterpreterState_Hold()</span></code></a>. There’s also a lack
of intuition that a standalone integer could have such a thing as
a reference count. <a class="reference internal" href="#c.PyInterpreterState_Lookup" title="PyInterpreterState_Lookup"><code class="xref c c-func docutils literal notranslate"><span class="pre">PyInterpreterState_Lookup()</span></code></a> sidesteps this
problem because the reference count is always associated with the returned
interpreter state, not the integer ID.</li>
</ul>
</section>
<section id="exposing-an-activate-deactivate-api-instead-of-ensure-clear">
<span id="pep-788-activate-deactivate-instead"></span><h3><a class="toc-backref" href="#exposing-an-activate-deactivate-api-instead-of-ensure-clear" role="doc-backlink">Exposing an <code class="docutils literal notranslate"><span class="pre">Activate</span></code>/<code class="docutils literal notranslate"><span class="pre">Deactivate</span></code> API instead of <code class="docutils literal notranslate"><span class="pre">Ensure</span></code>/<code class="docutils literal notranslate"><span class="pre">Clear</span></code></a></h3>
<p>In prior discussions of this API, it was
<a class="reference external" href="https://discuss.python.org/t/83959/2">suggested</a> to provide actual
<a class="reference external" href="https://docs.python.org/3/c-api/init.html#c.PyThreadState" title="(in Python v3.13)"><code class="xref c c-type docutils literal notranslate"><span class="pre">PyThreadState</span></code></a> pointers in the API in an attempt to
make the ownership and lifetime of the thread state clearer:</p>
<blockquote>
<div>More importantly though, I think this makes it clearer who owns the thread
state - a manually created one is controlled by the code that created it,
and once it’s deleted it can’t be activated again.</div></blockquote>
<p>This was ultimately rejected for two reasons:</p>
<ul class="simple">
<li>The proposed API has closer usage to
<a class="reference external" href="https://docs.python.org/3/c-api/init.html#c.PyGILState_Ensure" title="(in Python v3.13)"><code class="xref c c-func docutils literal notranslate"><span class="pre">PyGILState_Ensure()</span></code></a> &amp; <a class="reference external" href="https://docs.python.org/3/c-api/init.html#c.PyGILState_Release" title="(in Python v3.13)"><code class="xref c c-func docutils literal notranslate"><span class="pre">PyGILState_Release()</span></code></a>, which helps
ease the transition for old codebases.</li>
<li>It’s <a class="reference external" href="https://discuss.python.org/t/83959/15">significantly easier</a>
for code-generators like Cython to use, as there isn’t any additional
complexity with tracking <a class="reference external" href="https://docs.python.org/3/c-api/init.html#c.PyThreadState" title="(in Python v3.13)"><code class="xref c c-type docutils literal notranslate"><span class="pre">PyThreadState</span></code></a> pointers around.</li>
</ul>
</section>
<section id="using-pystatus-for-the-return-value-of-pythreadstate-ensure">
<h3><a class="toc-backref" href="#using-pystatus-for-the-return-value-of-pythreadstate-ensure" role="doc-backlink">Using <code class="docutils literal notranslate"><span class="pre">PyStatus</span></code> for the return value of <code class="docutils literal notranslate"><span class="pre">PyThreadState_Ensure</span></code></a></h3>
<p>In prior iterations of this API, <a class="reference internal" href="#c.PyThreadState_Ensure" title="PyThreadState_Ensure"><code class="xref c c-func docutils literal notranslate"><span class="pre">PyThreadState_Ensure()</span></code></a> returned a
<a class="reference external" href="https://docs.python.org/3/c-api/init_config.html#c.PyStatus" title="(in Python v3.13)"><code class="xref c c-type docutils literal notranslate"><span class="pre">PyStatus</span></code></a> instead of an integer to denote failures, which had the
benefit of providing an error message.</p>
<p>This was rejected because it’s <a class="reference external" href="https://discuss.python.org/t/83959/7">not clear</a>
that an error message would be all that useful; all the conceived use-cases
for this API wouldn’t really care about a message indicating why Python
can’t be invoked. As such, the API would only be needlessly harder to use,
which in turn would hurt the transition from <a class="reference external" href="https://docs.python.org/3/c-api/init.html#c.PyGILState_Ensure" title="(in Python v3.13)"><code class="xref c c-func docutils literal notranslate"><span class="pre">PyGILState_Ensure()</span></code></a>.</p>
<p>In addition, <a class="reference external" href="https://docs.python.org/3/c-api/init_config.html#c.PyStatus" title="(in Python v3.13)"><code class="xref c c-type docutils literal notranslate"><span class="pre">PyStatus</span></code></a> isn’t commonly used in the C API. A few
functions related to interpreter initialization use it (simply because they
can’t raise exceptions), and <a class="reference internal" href="#c.PyThreadState_Ensure" title="PyThreadState_Ensure"><code class="xref c c-func docutils literal notranslate"><span class="pre">PyThreadState_Ensure()</span></code></a> does not fall
under that category.</p>
</section>
</section>
<section id="open-issues">
<h2><a class="toc-backref" href="#open-issues" role="doc-backlink">Open Issues</a></h2>
<section id="when-should-the-legacy-apis-be-removed">
<span id="pep-788-deprecation"></span><h3><a class="toc-backref" href="#when-should-the-legacy-apis-be-removed" role="doc-backlink">When should the legacy APIs be removed?</a></h3>
<p><a class="reference external" href="https://docs.python.org/3/c-api/init.html#c.PyGILState_Ensure" title="(in Python v3.13)"><code class="xref c c-func docutils literal notranslate"><span class="pre">PyGILState_Ensure()</span></code></a> and <a class="reference external" href="https://docs.python.org/3/c-api/init.html#c.PyGILState_Release" title="(in Python v3.13)"><code class="xref c c-func docutils literal notranslate"><span class="pre">PyGILState_Release()</span></code></a> have been around
for over two decades, and it’s expected that the migration will be difficult.
Currently, the plan is to remove them in 10 years (opposed to the 5 years
required by <a class="pep reference internal" href="../pep-0387/" title="PEP 387 – Backwards Compatibility Policy">PEP 387</a>), but this is subject to further discussion, as it’s
unclear if that’s enough (or too much) time.</p>
<p>In addition, it’s unclear whether to remove them at all. A
<a class="reference external" href="https://docs.python.org/3/glossary.html#term-soft-deprecated" title="(in Python v3.13)"><span class="xref std std-term">soft deprecation</span></a> could reasonably fit for these
functions if it’s determined that a full <code class="docutils literal notranslate"><span class="pre">PyGILState</span></code> removal would
be too disruptive for the ecosystem.</p>
</section>
</section>
<section id="copyright">
<h2><a class="toc-backref" href="#copyright" role="doc-backlink">Copyright</a></h2>
<p>This document is placed in the public domain or under the
CC0-1.0-Universal license, whichever is more permissive.</p>
</section>
</section>
<hr class="docutils" />
<p>Source: <a class="reference external" href="https://github.com/python/peps/blob/main/peps/pep-0788.rst">https://github.com/python/peps/blob/main/peps/pep-0788.rst</a></p>
<p>Last modified: <a class="reference external" href="https://github.com/python/peps/commits/main/peps/pep-0788.rst">2025-04-30 16:59:34 GMT</a></p>

        </article>
        <nav id="pep-sidebar">
            <h2>Contents</h2>
            <ul>
<li><a class="reference internal" href="#abstract">Abstract</a></li>
<li><a class="reference internal" href="#motivation">Motivation</a><ul>
<li><a class="reference internal" href="#native-threads-will-always-hang-during-finalization">Native threads will always hang during finalization</a><ul>
<li><a class="reference internal" href="#using-py-isfinalizing-is-insufficient">Using <code class="docutils literal notranslate"><span class="pre">Py_IsFinalizing</span></code> is insufficient</a></li>
<li><a class="reference internal" href="#daemon-threads-can-cause-finalization-deadlocks">Daemon threads can cause finalization deadlocks</a></li>
<li><a class="reference internal" href="#we-can-t-change-finalization-behavior-for-pygilstate-ensure">We can’t change finalization behavior for <code class="docutils literal notranslate"><span class="pre">PyGILState_Ensure</span></code></a></li>
</ul>
</li>
<li><a class="reference internal" href="#the-existing-apis-are-broken-and-misleading">The existing APIs are broken and misleading</a><ul>
<li><a class="reference internal" href="#pygilstate-ensure-generally-crashes-during-finalization"><code class="docutils literal notranslate"><span class="pre">PyGILState_Ensure</span></code> generally crashes during finalization</a></li>
<li><a class="reference internal" href="#the-term-gil-is-tricky-for-free-threading">The term “GIL” is tricky for free-threading</a></li>
</ul>
</li>
<li><a class="reference internal" href="#subinterpreters-don-t-work-with-pygilstate-ensure">Subinterpreters don’t work with <code class="docutils literal notranslate"><span class="pre">PyGILState_Ensure</span></code></a><ul>
<li><a class="reference internal" href="#interpreters-can-concurrently-shut-down">Interpreters can concurrently shut down</a></li>
</ul>
</li>
</ul>
</li>
<li><a class="reference internal" href="#rationale">Rationale</a><ul>
<li><a class="reference internal" href="#replacing-the-old-apis">Replacing the old APIs</a></li>
<li><a class="reference internal" href="#a-light-layer-of-magic">A light layer of magic</a></li>
<li><a class="reference internal" href="#bikeshedding-and-the-pythreadstate-namespace">Bikeshedding and the <code class="docutils literal notranslate"><span class="pre">PyThreadState</span></code> namespace</a></li>
<li><a class="reference internal" href="#preventing-interpreter-finalization-with-references">Preventing interpreter finalization with references</a></li>
</ul>
</li>
<li><a class="reference internal" href="#specification">Specification</a><ul>
<li><a class="reference internal" href="#daemon-and-non-daemon-threads">Daemon and non-daemon threads</a></li>
<li><a class="reference internal" href="#interpreter-reference-counting">Interpreter reference counting</a></li>
<li><a class="reference internal" href="#ensuring-and-releasing-thread-states">Ensuring and releasing thread states</a></li>
<li><a class="reference internal" href="#deprecation-of-pygilstate-apis">Deprecation of <code class="docutils literal notranslate"><span class="pre">PyGILState</span></code> APIs</a></li>
</ul>
</li>
<li><a class="reference internal" href="#backwards-compatibility">Backwards Compatibility</a></li>
<li><a class="reference internal" href="#security-implications">Security Implications</a></li>
<li><a class="reference internal" href="#how-to-teach-this">How to Teach This</a><ul>
<li><a class="reference internal" href="#examples">Examples</a><ul>
<li><a class="reference internal" href="#single-threaded-example">Single-threaded example</a></li>
<li><a class="reference internal" href="#transitioning-from-old-functions">Transitioning from old functions</a></li>
<li><a class="reference internal" href="#daemon-thread-example">Daemon thread example</a></li>
<li><a class="reference internal" href="#asynchronous-callback-example">Asynchronous callback example</a></li>
</ul>
</li>
</ul>
</li>
<li><a class="reference internal" href="#reference-implementation">Reference Implementation</a></li>
<li><a class="reference internal" href="#rejected-ideas">Rejected Ideas</a><ul>
<li><a class="reference internal" href="#using-an-interpreter-id-instead-of-a-interpreter-state-for-pythreadstate-ensure">Using an interpreter ID instead of a interpreter state for <code class="docutils literal notranslate"><span class="pre">PyThreadState_Ensure</span></code></a></li>
<li><a class="reference internal" href="#exposing-an-activate-deactivate-api-instead-of-ensure-clear">Exposing an <code class="docutils literal notranslate"><span class="pre">Activate</span></code>/<code class="docutils literal notranslate"><span class="pre">Deactivate</span></code> API instead of <code class="docutils literal notranslate"><span class="pre">Ensure</span></code>/<code class="docutils literal notranslate"><span class="pre">Clear</span></code></a></li>
<li><a class="reference internal" href="#using-pystatus-for-the-return-value-of-pythreadstate-ensure">Using <code class="docutils literal notranslate"><span class="pre">PyStatus</span></code> for the return value of <code class="docutils literal notranslate"><span class="pre">PyThreadState_Ensure</span></code></a></li>
</ul>
</li>
<li><a class="reference internal" href="#open-issues">Open Issues</a><ul>
<li><a class="reference internal" href="#when-should-the-legacy-apis-be-removed">When should the legacy APIs be removed?</a></li>
</ul>
</li>
<li><a class="reference internal" href="#copyright">Copyright</a></li>
</ul>

            <br>
            <a id="source" href="https://github.com/python/peps/blob/main/peps/pep-0788.rst">Page Source (GitHub)</a>
        </nav>
    </section>
    <script src="../_static/colour_scheme.js"></script>
    <script src="../_static/wrap_tables.js"></script>
    <script src="../_static/sticky_banner.js"></script>
    <script src="https://analytics.python.org/js/script.outbound-links.js"
            data-domain="peps.python.org" defer></script>
</body>
</html>